generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Admin {
  id         Int       @id @default(autoincrement())
  username   String    @unique
  password   String
  full_name  String
  parentName String? // Now optional
  gender     String? // Now optional
  email      String?
  phone      String? // Now optional
  address    String? // Now optional
  dob        DateTime?
  img        String?
  bloodType  String?
  role       String    @default("admin")
  createdAt  DateTime  @default(now())
}

model Grade {
  id           Int            @id @default(autoincrement())
  level        String         @unique
  classes      Class[]
  Homework     Homework[]
  feestructure FeeStructure[] @relation("GradeToFeesStructure") // ✅ One-to-many relation
}

model Class {
  id           Int            @id @default(autoincrement())
  name         String         @unique(map: "Class_name_key")
  supervisorId String?        @unique // * Ensures one teacher per class // * ❌ Remove @unique here to allow multiple classes to have the same supervisor
  gradeId      Int
  Announcement Announcement[]
  attendance   Attendance[]
  events       Event[]
  exams        Exam[]
  homeworks    Homework[]
  lessons      Lesson[]
  students     Student[]
  Grade        Grade          @relation(fields: [gradeId], references: [id], onDelete: Cascade)
  Teacher      Teacher?       @relation(name: "ClassToTeacher", fields: [supervisorId], references: [id]) // One-to-One relation.

  @@index([gradeId], map: "Class_gradeId_idx")
  @@index([supervisorId], map: "Class_supervisorId_idx")
  @@map("class")
}

model Lesson {
  id        Int       @id @default(autoincrement())
  name      String    @unique
  day       LessonDay
  startTime DateTime
  endTime   DateTime
  subjectId Int
  classId   Int
  teacherId String
  Class     Class     @relation(fields: [classId], references: [id], onDelete: Cascade)
  Subject   Subject   @relation(fields: [subjectId], references: [id], onDelete: Cascade)
  Teacher   Teacher   @relation(fields: [teacherId], references: [id], onDelete: Cascade)

  @@index([classId])
  @@index([subjectId])
  @@index([teacherId])
}

// * Message Related Models

model Announcement {
  id          Int      @id @default(autoincrement())
  title       String
  description String
  date        DateTime
  classId     Int?
  Class       Class?   @relation(fields: [classId], references: [id])

  @@index([classId])
}

model Attendance {
  id        Int      @id @default(autoincrement())
  date      DateTime
  present   Boolean
  studentId String
  classId   Int
  class     Class    @relation(fields: [classId], references: [id], onDelete: Cascade)
  Student   Student  @relation(fields: [studentId], references: [id], onDelete: Cascade)

  @@index([studentId])
}

model Event {
  id          Int      @id @default(autoincrement())
  title       String
  description String
  startTime   DateTime
  endTime     DateTime
  classId     Int?
  Class       Class?   @relation(fields: [classId], references: [id])

  @@index([classId])
}

model Exam {
  id       Int           @id @default(autoincrement())
  title    String
  date     DateTime
  classId  Int
  Class    Class         @relation(fields: [classId], references: [id], onDelete: Cascade)
  subjects ExamSubject[]
  results  Result[]

  @@index([classId])
}

model ExamSubject {
  id        Int     @id @default(autoincrement())
  examId    Int
  subjectId Int
  maxMarks  Int
  Exam      Exam    @relation(fields: [examId], references: [id], onDelete: Cascade)
  Subject   Subject @relation(fields: [subjectId], references: [id], onDelete: Cascade)

  @@unique([examId, subjectId])
}

model Homework {
  id          Int      @id @default(autoincrement())
  description String
  date        DateTime @default(now()) @db.Timestamptz // ✅ Store with timezone
  classId     Int
  Class       Class    @relation(fields: [classId], references: [id], onDelete: Cascade)
  gradeId     Int
  Grade       Grade    @relation(fields: [gradeId], references: [id]) // ✅ Ensure relation is defined

  // subjectId   Int
  // Subject     Subject  @relation(fields: [subjectId], references: [id], onDelete: Cascade)
  // @@index([subjectId])

  @@index([classId])
}

model Result {
  id        Int     @id @default(autoincrement())
  score     Float
  studentId String
  examId    Int
  subjectId Int
  Exam      Exam    @relation(fields: [examId], references: [id], onDelete: Cascade)
  Student   Student @relation(fields: [studentId], references: [id], onDelete: Cascade)
  Subject   Subject @relation(fields: [subjectId], references: [id], onDelete: Cascade)

  @@index([examId])
  @@index([studentId])
  @@index([subjectId])
}

// * Student Related Models

model Student {
  id           String         @id
  username     String         @unique
  name         String
  surname      String?
  parentName   String
  email        String?        @unique
  phone        String
  address      String
  img          String?
  bloodType    String?
  gender       Gender
  dob          DateTime
  createdAt    DateTime       @default(now())
  deletedAt    DateTime?
  classId      Int
  Attendance   Attendance[]
  results      Result[]
  Class        Class          @relation(fields: [classId], references: [id], onDelete: Cascade)
  studentFees  StudentFees[]
  clerkStudent ClerkStudents?
  clerk_id     String?        @unique

  @@index([classId])
}

model ClerkStudents {
  clerk_id  String   @id @db.VarChar // Keep as primary key
  user_id   String?  @unique // New column for Clerk User ID
  username  String   @unique
  password  String   @db.VarChar
  full_name String   @db.VarChar
  role      String   @default("student") @db.VarChar
  studentId String?  @unique @db.VarChar // Foreign Key (Optional, in case some users aren't students)
  student   Student? @relation(fields: [studentId], references: [id], onDelete: Cascade) // Inverse Relation
}

model Subject {
  id        Int              @id @default(autoincrement())
  name      String           @unique
  createdAt DateTime         @default(now())
  exams     ExamSubject[]
  // homeworks Homework[]
  lessons   Lesson[]
  results   Result[]
  teachers  TeacherSubject[]
}

// * Teacher Related Models

model Teacher {
  id            String           @id
  username      String           @unique
  name          String
  surname       String?
  email         String?          @unique
  phone         String
  address       String
  img           String?
  bloodType     String?
  gender        Gender
  createdAt     DateTime         @default(now())
  deletedAt     DateTime?
  supervisor    Boolean          @default(false)
  dob           DateTime?
  lessons       Lesson[]
  subjects      TeacherSubject[]
  class         Class?           @relation(name: "ClassToTeacher") // Opposite relation defined WITHOUT fields/references
  classId       String?          @unique
  ClerkTeachers ClerkTeachers?
  clerk_id      String?          @unique
}

model TeacherSubject {
  teacherId String
  subjectId Int
  Subject   Subject @relation(fields: [subjectId], references: [id], onDelete: Cascade)
  Teacher   Teacher @relation(fields: [teacherId], references: [id], onDelete: Cascade)

  @@id([teacherId, subjectId])
}

model ClerkTeachers {
  clerk_id  String   @id @db.VarChar // Keep as primary key
  user_id   String?  @unique // New column for Clerk User ID
  username  String   @unique
  password  String   @db.VarChar
  full_name String   @db.VarChar
  role      String   @default("teacher") @db.VarChar
  teacherId String?  @unique @db.VarChar // Foreign Key (Optional, in case some users aren't teachers)
  teacher   Teacher? @relation(fields: [teacherId], references: [id], onDelete: Cascade) // Inverse Relation
}

// * Fees Related Models

model FeeStructure {
  id           Int      @id @default(autoincrement())
  gradeId      Int // ✅ Foreign key reference to Grade
  term         Term
  academicYear String
  startDate    DateTime
  dueDate      DateTime
  termFees     Int
  abacusFees   Int?

  studentFees StudentFees[] // ✅ One-to-Many: Links fee payments
  grade       Grade         @relation("GradeToFeesStructure", fields: [gradeId], references: [id]) // ✅ gradeId references Grade

  @@unique([gradeId, term, academicYear]) // Ensures a unique fee per term for each grade
}

model FeeTransaction {
  id            Int      @id @default(autoincrement())
  studentFeesId Int // ✅ Links to StudentFees
  fbNumber      String   @unique // ✅ Unique fees book number
  amountPaid    Int
  paymentDate   DateTime @default(now())
  discountGiven Int      @default(0) // ✅ New: Discount applied in this transaction
  fineCollected Int      @default(0) // ✅ New: Fine collected in this transaction

  studentFees StudentFees @relation(fields: [studentFeesId], references: [id]) // ✅ Links to StudentFees
}

model StudentFees {
  id               Int         @id @default(autoincrement())
  studentId        String // ✅ Foreign key reference to Student
  feeStructureId   Int // ✅ Foreign key reference to FeeStructure
  fbNumber         String      @unique // ✅ Unique fees book number
  term             Term
  paidAmount       Int         @default(0) // Tracks total paid
  discountAmount   Int         @default(0) // ✅ New: Discounts applied
  fineAmount       Int         @default(0) // ✅ New: Fines applied
  abacusPaidAmount Int? // ✅ Allows tracking partial Abacus payments
  receivedDate     DateTime    @default(now())
  receiptDate      DateTime
  paymentMode      PaymentMode @default(CASH) // ✅ New: Payment mode (CASH, ONLINE, UPI, BANK_TRANSFER)

  student         Student          @relation(fields: [studentId], references: [id])
  feeStructure    FeeStructure     @relation(fields: [feeStructureId], references: [id]) // ✅ Links to FeeStructure
  feeTransactions FeeTransaction[] // ✅ One-to-Many: Links fee payments

  // ✅ Total Due Calculation (handled in queries)
  // totalDue = termFees - paidAmount - discountAmount + fineAmount
  @@unique([studentId, term, fbNumber])
}

enum LessonDay {
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
}

enum Gender {
  Male
  Female
}

enum Term {
  TERM_1
  TERM_2
  TERM_3
  TERM_4
}

enum PaymentMode {
  CASH
  ONLINE
  UPI
  BANK_TRANSFER
}
